this challenge is a pwnable where you play a "tank game". the player controls two float parameters: the angle and power of a "bullet". these values are constrained to be between 0-33 inclusive for power, and 0-90 inclusive for angle. the power value is interpreted as meters per second in a simple calculation for determining the trajectory of the projectile, which will "land" somewhere within an array of size 112, overwriting that index with the "ammo type". using the max power with an angle of 45 will land at index 111, overwriting the null pointer at the end of the string but not actually allowing for any actual memory corruption. Pretty much all variables in this game that SHOULD be constants are instead stack variables. By default, players only have the default ammo type of "". on hitting 3 enemies in a row, players will start earning "specialty ammo", "-". Specialty ammo lands in a "splash", meaning it overwrites the target byte as well as an additional byte at both target + 1 and target - 1. the variable controlling max projectile power is on the stack as the next variable after the "field" that players are firing projectiles into, i.e. overwriting field[112] (one index past what is possible with conventional ammo) will start overwriting the max_power integer. by firing specialty ammo at field[111] the splash will overwrite the least significant byte of max_power, increasing max power to ord("-") (45). this extra range can then be used to overwrite the rest of the integer. A similar trick can be used to overwrite the "max_angle" value which is currently 90, by firing a shot with specialty ammo at field[0]. this overwrites the most significant byte of angle, and lets you set angles >90, allowing you to fire "backwards". with both extra power and the ability to fire backwards, you can now overwrite the max_misses counter to essentially give yourself unlimited lives, as each time you overwrite memory it registers as a "miss" and removes one of your five lives. Next value to overwrite is the "num_ammo_types" integer, which will allow you to index past the "-" ammo type selection. any ammo type that is not "-" is treated like a "", i.e. a single byte overwrite. you can load arbitrary bytes into memory by "failing" the first strcmp check for "pew!" and instead sending "AAAAAA" + 1 arbitrary byte. When you send "pew!" in the next iteration of the loop, the first 6 as are overwritten by "pew!\n\x00" but the last byte remains in memory for the next round's ammo type selection. alternatively, there are a number of values on the stack that increment/decrement each turn, most of which can be used as your new ammo type. regardless of how you acquire the bytes, they can then be shot onto the return pointer. after that you just need to end the game by running out of lives, at which point if you modify the return pointer to point at the free shell function which will just drop you into a shell. Alternatively, if the free shell function were missing, players now essentially have a 1-byte read primitive by selecting some arbitrary memory index and firing it into one of the strings that are printed as part of the UI. this can be used to leak a libc address, and the libc version can be provided for a classic return2libc exploit.

bonus: this is the exact same binary as tank-game except the free shell function was removed. I didn't write a solver but the only extra steps involve leaking a libc address via the printable strings and performing a ret2libc.
